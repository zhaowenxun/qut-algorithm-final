## 分治法

### 归并排序：

输入：待排序数组r[n],待排序区间[s,t]

输出：升序序列r[s]~r[t]

1. 如果s等于t，待排区间只有一个记录，算法结束；
2. 计算区间重点：mid=（s+t）/2;
3. 对前半个子序列r[s]~r[m]采用归并排序进行升序排列；
4. 对后半个子序列r[m+1]~r[t]采用归并排序进行升序排列；
5. 合并两个升序序列r[s] ~ r[m]和r[m+1] ~ r[t]

### 快速排序：

输入：待排序数组r[n],待排序区间[s,t]

输出：升序序列r[s]~r[t]

1. 如果s等于t，待排区间只有一个记录，算法结束

2. 初始化l=r[s-1],m=r[t+1], x=r[s]

3. while(l<m):

   3.1 如果r[l]<x，则l++，继续步骤3.1；

    否则跳转到步骤3.2;

   3.2 如果r[m]>x,则m--，继续步骤3.2；

   否则跳转到步骤3.3;

   3.3 交换r[l]和r[m]内的值，继续步骤3;

4. 对半个子序列r[s]~r[l]进行快速排序

5. 对半个子序列r[l+1]~r[t]进行快速排序


### 最近点对问题

输入：按照x坐标升序排列的n个点的集合 S={(x~1~,y~1~),(x~2~,y~2~),....} （n>=2）

输出：最近点对的距离

1. 如果n等于2，则返回(x~1~,y~1~),(x~2~,y~2~)的距离，算法结束;

2. 划分：m=S中各点x坐标的中位数;   //通过x=m进行划分

3. d1=计算{(x~1~,y~1~),...(x~m~,y~m~)}的最近点对距离;

4. d2=计算{(x~m~,y~m~)....(x~n~,y~n~)}的最近点对距离;

5. d=min{d1,d2};

6. 依次考察集合S中的点p(x,y)，如果（x<=x~m~ 并且 x>=x~m~ -d），则将点p加入到P1中；

   同样，如果（x>=x~m~ 并且x<=x~m~+d），则将p加入到P2中

7. 将P1和P2按y坐标升序排列；

8. 对几何P1和P2中的每个点p(x,y)，在[y,y+d]内最多选出8个候选点，计算点p的最近距离d3

9. 返回min{d,d~3~};

### 最大子段和问题：O(nlog~2~n)  ==直接去看DP求解方法==

输入：待求解数组r[n]和求解区间[s,t]

输出：r[s]~r[t]的最大子段和maxSum

1. 如果s=t则区间内只有一个值，最大子段和为r[s],程序结束；
2. 计算划分中点 m=(s+t)/2;
3. leftSum=计算r[s]~r[m]的最大子段和
4. rightSum=计算r[m+1]~r[t]的最大子段和；
5. 从r[m]开始往左逐个加和，计算以r[m]为结尾的最大子段和l；
6. 从r[m+1]开始往右逐个加和，计算以r[m+1]未开始的最大子段和r；
7. 返回max（leftSum,max(rightSum,l+r)；



