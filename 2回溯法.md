## 回溯法：DFS

从解空间的根结点出发，按照==深度优先==策略进行搜索满足约束条件的解，为了优化，可以采用==剪枝==跳过一些结点

#### 例题：素数环问题：https://www.luogu.com.cn/problem/UVA524

~~~ cpp
PrimeCircle:
memset(book,1,sizeof(book)); 初始化记录数组为0
memset(x,1,sizeof(x));初始化解数组为0
    dfs(int k){
    if(k==n)输出结果并return
    for(int i=2;i<=n;i++)
        if(check(i,k)&&book[i]){
            book[i]=1;
            dfs(k+1);
            book[i]=0;
        }
}
bool check(int t，int k){
	if(x==n-1)检查t与1还有t与x[k-1]和是否都为素数
    else 检查t与x[k-1]和是否为素数
}
dfs(1);
~~~

### 图问题中的回溯法

#### 图着色问题：

输入：图G(V,E),m种颜色

输出：n个顶点的涂色情况color[m]

1. 将数组color[n]初始化为0；

2. k=0;

3. while(k>=0)

   3.1 依次考察每一种颜色，若顶点k的着色与其他顶点着色==不发生冲突==，则转步骤3.2；

   ​	否则，搜索下一个颜色；

   3.2 若所有顶点都已经着色，则输出数组color，程序结束；

   3.3 若顶点k是一个==合法着色==，则k++,转步骤3处理下一个结点；

   3.4 否则，重置顶点k的着色情况，k=k-1，转步骤3回溯；

#### 哈密顿回路问题：所有点都走一次且仅一次，后回到原点

输入：无向图 G=(V,E)

输出：哈密顿回路解向量x[n]

1. 将数组x[n]初始化为0，标志数组visited[n]初始化为0；

2. 从顶点0开始构造哈密顿回路：x[0]=1;visited[0]=1;k=1;

3. while(k>=1)

   3.1 x[k]=x[k]+1,搜索下一个顶点；

   3.2 若n个顶点没有遍历完，则执行下列操作

   ​	3.2.1 若顶点x[k]不在哈密顿回路上并且(x[k-1],x[k])属于E,转步骤3.3

   ​	3.2.2 否则，x[k]=x[k]+1,搜索下一个顶点

   3.3 若数组x[n]已经形成哈密顿路径，则输出x[n]，算法结束

   3.4 若数组x[n]构成哈密顿路径的部分解，则k=k+1，转步骤3

   3.5 否则，取消x[k]的访问标指，x[k]=0,k=k-1,进行回溯，转步骤3

### 组合问题中的回溯法

#### n皇后问题：采用==伪代码==可以省略判断函数 少写很多东西

![img](\wps1.jpg)

首先肯定每一行一个皇后，则我们==只需要判断皇后应该放在那一列==即可

关于k：k代表的是当前遍历到哪一个皇后，如果当前列不满足则x[k]++去检查下一列，如果出界则x[k]=-1恢复状态 然后k--去回溯上一个皇后的位置，==如果最后回溯到k<1则代表无解则退出循环结束，如果k=n则表示搜索到相应解进行return结束==

#### 作业调度问题

输入：n个作业在机器1上处理时间a[n],在机器2上处理时间为b[n]

输出:   最优调度序列 x[n]

1. 初始化调度向量x[n]={-1};最短完成时间bestTime = Max;

2. 初始化调度方案中机器1和机器2完成时间：sum1[n]=sum2[n]={0};k=1;

3. while(k>=1)

   3.1 依次考察每一个作业，如果作业x[k]未处理，则跳转至步骤3.2，否则x[k]++,尝试下一个作业;

   3.2 处理作业x[k]:

   ​	3.2.1 sum1[k]=sum1[k-1]+a[x[k]];

   ​	3.2.2 sum2[k]=max{sum1[k],sum2[k-1]}+b[x[k]];

   ​	3.2.3 若sum2[k]<bestTime 则跳转步骤3.3否则实施剪枝

   3.3 若n个作业都处理完，则输出一个解

   3.4 若尚有作业没被处理，则k++,转步骤3处理下一个作业

   3.5 回溯，x[k]=-1,k-- 转步骤3 重新处理第k个作业

   

