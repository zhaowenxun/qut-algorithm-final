## DP:

### 数塔问题：

输入：二维数组d[n\][n\]

输出：最大值

1. 初始化数组ans最后一行为d数组最后一行
2. 从n-1行开始遍历到第一行：
   1. ans[i\][j\]=d[i\][j\]+max(ans[i+1\][j\],ans[i+1\][j+1\]);
   2. 如果选择下标为j的元素，path[i\][j\]=j;否则为j+1；
3. 输出最大值ans[1\][1\];
4. 根据从path[1\][1]开始回溯得到每一层决策的列下标，输出路径信息。

### 多段图最短路径：

![image-20201207132156784](\image-20201207132156784.png)

cost[i]为从0到的最短路径。

输入：多段图的代价矩阵

输入：最短路径长度及路径

1. 循环变量j从1~n-1重复下述操作，执行填表工作：
   1. 考察顶点j的所有入边，对于边(i,j)属于E:
      1. cost[j\]=min{cost[i]+c~ij~};
      2. path[j]=使cost[i]+C~ij~ 最小的i；
2. 输出最短路径长度cost[n-1];
3. 循环变量i=path[n-1]，循环到path[i]=0:
   1. 输出path[i];
   2. i=path[i]；

### 最长上升子序列：

设L(n)为以a~n~ 结尾的最长递增子序列长度；

L(i)= max{f[j]+1}(j<i&&a~j~<a~i~)

L(0)=0;

### 最长公共子序列：

L(m,n)表示序列X={x~1~，x~2~...x~m~}和序列Y={y~1~,y~2~,.....y~n~}的公共子序列长度。

if(x[m]==y[n])L(m,n)=L(m-1,n-1)+1;

L(m,n)=max(L(m-1,n),L(m,n-1)); 

边界：L(i,0)=L(0,i)=0;

### 0/1背包：

F(i,j)表示从前i各物品中选取了总体积为j的物品放入背包后物品的最大价值和；

F(i,j)=max(F(i-1,j),F(i-1,j-V~i~)+W~i~);

F（0，0）=0；其他都为0xcf

~~~c++
memset(f,0xcf,sizeof(f));
f[0][0]=0;
for(int i=1;i<=n;i++){
    for(int j=0;j<=m;j++)//数组更新
        f[i][j]=f[i-1][j];//没选
    for(int j=v[i];j<=m;j++)
        f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]);
}
~~~

经过时间（去掉一维没影响）和空间优化（i&1进行滚动数组）

~~~ c++
memset(f,0xcf,sizeof(f));
f[0]=0;
for(int i=1;i<=n;i++)
    for(int j=m;j>=v[i];j--)//m为背包容量 此处逆序由于此时f[0~v[i]]为i-1状态，后边为i状态，随着j减小，逐渐从i-1状态转向i状态，不能正序。
        f[j]=max(f[j],f[j-v[i]]+w[i]);
int ans=0;
for(int i=0;i<=m;i++)
    ans=max(ans,f[i]); 
~~~



### 最大子段和：

L(n)表示以a~n~为结尾的最大子段和

L(n)=max(L(n-1),L(n-1)+a~n~,a~n~);



